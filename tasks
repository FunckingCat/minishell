Файл с текущими задачами и фитбеками и заметками

Я смочь поключить гид

[x] Показывать приглашение для ввода 'minishell >'
	[x] Выделить цветом
[x] Обработка ошибок
	[x] Выделить цветом
[ ] Пайпланы
	[ ] Поиск и запуск исполняемого файла (PATH, относ. или абс. путь)
[x] История
[ ] Парсинг
	[x] 1 уровень - парсинг по пайпам
		[x] Одинарные кавычки (игнорирует все специальные символы)
		[x] Двойные кавычки (игнорирует все специальные символы, кроме $)
	[x] 2 уровень - парсинг редиректов
		[x] Влево: "<f1 <f2" читается только f2
		[x] Влево: "<f1<f2"  это валидный ввод
		[x] Влево: "<f1 <<f" читается только многострочный
		[x] Влево: "<f1<<f"  валидно
		[x] Влево: "<<f<f1"  валидно многострочный читается читает из f1
		[x] Влево: Общее правило открываются все читается последний
		[x] Вправо: так же без пробелов валидно
		[x] Вправо: так же открываются все пишется в последний
		[x] Редиректы парсятся до запуска процессов
	[ ] 3 уровень - парсинг аргументов для процессов
		[ ] Переменные окружения $ (должны раскрываться в значения)
[x] Редиректы (функция возвр. файловый дискриптор по имени файла) 
	[x] Редиректы < (перенаправить ввод) и > (перенаправить вывод)
		[x] Стремный синтаксис: "<>filename" читает из файла
		[x] Стремный синтаксис: "><filename" ошибка bash: syntax error near unexpected token '<'
		[x] Стремный синтаксис: ">>>filename" такая же ошибка
	[x] << читать ввод из текущего источника
	[x] >> перенаправить вывод с режимом добавления
[ ] Сигналы
	[ ] ctrl-C
		[ ] При пустой строке ввода: напечатать 'minishell >' на новой строке
		[ ] С текстом строке ввода: напечатать 'minishell >' на новой строке
		[ ] В интерактивном режиме: напечатать 'minishell >' на новой строке
	[ ] ctrl-D
		[ ] При пустой строке ввода: выйти из minishell
		[ ] С текстом строке ввода: ничего не делать
		[ ] В интерактивном режиме: выйти из программы
	[ ] ctrl-\ 
		[ ] При пустой строке ввода: ничего не делать
		[ ] С текстом строке ввода: выйти из minishell
		[ ] В интерактивном режиме: ничего не делать
[N] Манипулирование ENV
	[ ] ShellLevell - уровень шела
	[ ] $? статус выхода предыдущей команды - (Проверка: "echo $?" и "expr $? + $?")
[ ] Тексты ошибок
[ ] Команды
	[ ] Какая то система вызова команд
	[ ] echo
		[ ] без флага
		[ ] флаг -n
		[ ] несколько агрументов
	[ ] cd - нужен env
		[ ] отностильный путь
		[ ] аболютный путь
    [ ] oldpwd в env
	[ ] pwd
	[x] export
	[x] unset
	[x] env
	[ ] exit

<------------------------------------------------------------------------------>

Задача записывается как
[ ] Текст задачи (комментарий)
	[ ] Не выполненная подзадача - filename.c (комментарий)
	[x] Выполненная подзадача (комменарий)
	[P] Выполненная подзадача c проблемами (описание проблемы)
[x] Выполненная задача

Шаблоны:
[ ] 
	[ ] 
		[ ] 

*** Как работать с Git в команде ***

1. в master всегда рабочий код который можно собрать и запустить
2. работа ведется в dev, но и в dev код всегда рабочий, тоесть не падает
3. работа ведется по задачам:
	3.1 взяли свою задачу, сделлали ветку от dev и назвали как то адеватно, например task_id/short_task_description
	3.2 как сделали  задачу, проверили что ваш код ничего не ломает, закоммитили с нормальным сообщением и делаем пулл на сервер
	3.3 второй член вашей команды делакт ревью и мержит ваш код с веткой dev
	3.4 постарайтесь работать с разделением зон ответственности

Разрешение конфликтов:
	Конфликты синхронизации происходят, если выполнены оба условия
		1. один и тот же файл был изменен как в локальном, так и в удаленном репозитории
		2. автоматическое слияние изменений не произошло, поскольку изменения находятся в одном и том же месте файла.

Проверка статуса
		git status
	результат
		> On branch master <== ветка в которой находишься
		> Your branch is ahead of 'origin/master' by 2 commits. <== то что происходит в главной ветке
		> nothing to commit (working directory clean) <== что происходит у тебя в ветке

Восстановление файлов
	Если файл был изменен или удален, но его необходимо восстановить, следует использовать команду:
		> git checkout doc_src/git_short_manual.rst
		> git checkout 123.txt
		> git checkout . <== вернет все файлы в исходное состояние

Коммит
	Добавление файлов
		> git add .          <== Добавить все изменения
		> git add 123.txt    <== Добавить в конкретном файле

	Сам Коммит
		> git commit -m [Осмыленное описание изменений]

Синхронизация между репозиториями
	Из удаленного - в локальный (скачать себе)
		> git pull
	если в удаленном репозитории нет изменений то выведет:
		> Already up-to-date.
	Команда git pull не всегда приводит к успешной синхронизации. Результат в случае наличия конфликтов:
		> warning: Cannot merge binary files: blender/landscape_objects/Fallen_tree.blend (...)
		> 
		> Auto-merging blender/landscape_objects/Fallen_tree.blend
		> CONFLICT (content): Merge conflict in blender/landscape_objects/Fallen_tree.blend
		> Automatic merge failed fix conflicts and then commit the result.

	Можно просмотреть лог изменений:
		> git log
	
	Из локального - в удаленный (отправить на сервер)
		> git push

Ветвление
	"Новая задача - новая ветка."
	Создание новой ветки
		> git checkout -b [новая_ветка] <== создаьб новую ветку

	Переключение между ветками
		> git checkout [ветка]

	Удаление ветки
		> git branch -d [ветка]

	Обязательно нужно делать пуш изменений в общий репозиторий:
		> git push origin [ветка]

	Запрос изменений с сервера
		> git pull [ветка]

	Слияние веток
		Чтобы слить ветку в ту, с которой вы сейчас работаете, используйте:
			> git merge [ветка]

		Ветки можно сравнить:
			> git diff [одна_ветка] [другая_ветка]

Статья: https://mandarinshow.ru/news/id/30

Полезные git алиасы:
	alias glog="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"

Статья по readline: https://russianblogs.com/article/7614321785/